Return-Path: <linux-xfs-owner@vger.kernel.org>
X-Original-To: lists+linux-xfs@lfdr.de
Delivered-To: lists+linux-xfs@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 9F46C5F5CBD
	for <lists+linux-xfs@lfdr.de>; Thu,  6 Oct 2022 00:31:21 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229777AbiJEWbU (ORCPT <rfc822;lists+linux-xfs@lfdr.de>);
        Wed, 5 Oct 2022 18:31:20 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:42486 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229575AbiJEWbT (ORCPT
        <rfc822;linux-xfs@vger.kernel.org>); Wed, 5 Oct 2022 18:31:19 -0400
Received: from ams.source.kernel.org (ams.source.kernel.org [IPv6:2604:1380:4601:e00::1])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 84D3483F38;
        Wed,  5 Oct 2022 15:31:18 -0700 (PDT)
Received: from smtp.kernel.org (relay.kernel.org [52.25.139.140])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by ams.source.kernel.org (Postfix) with ESMTPS id 4053EB81F77;
        Wed,  5 Oct 2022 22:31:17 +0000 (UTC)
Received: by smtp.kernel.org (Postfix) with ESMTPSA id F25C4C433C1;
        Wed,  5 Oct 2022 22:31:15 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=k20201202; t=1665009076;
        bh=geeZzqd/97Lk7u8OTXKlkY8/eN54gNc2JGFCBAndfmA=;
        h=Subject:From:To:Cc:Date:In-Reply-To:References:From;
        b=MteuWeTAGNdDzJLGmQBTBmwnuULdIUyeqtA+HQKUcR+80JrTibmo8Dl1DuKXgc1cq
         /+53w84+VeZVtJ/TOFqZXLCJqly+1sCchLM+4+Ns+sbbGQRs/l9WxBQQiQAqowgozR
         V5rfSwm3OenWv3+jxFBVHoUsSEs7uQp/YhP0dMR4iRs9FW6NlOFmooL4tmvIXqKaH9
         BG9qRdwq9KUZqqvNbnQxmydQq59EBEjMgTOSi3EY+xQQ0ESvJV0ZTzHTLQpuJhi/Lm
         1zyuV52scULLAsyKkYuRf59FSX3G5u31oJR4iTsRfGKtIYsGi/KGRwfh2Om0BaA/x0
         /C9kuZ7UFisVw==
Subject: [PATCH 1/2] check: detect and preserve all coredumps made by a test
From:   "Darrick J. Wong" <djwong@kernel.org>
To:     djwong@kernel.org, guaneryu@gmail.com, zlang@redhat.com
Cc:     linux-xfs@vger.kernel.org, fstests@vger.kernel.org, guan@eryu.me
Date:   Wed, 05 Oct 2022 15:31:15 -0700
Message-ID: <166500907546.887104.248083399669088204.stgit@magnolia>
In-Reply-To: <166500906990.887104.14293889638885406232.stgit@magnolia>
References: <166500906990.887104.14293889638885406232.stgit@magnolia>
User-Agent: StGit/0.19
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
X-Spam-Status: No, score=-7.1 required=5.0 tests=BAYES_00,DKIMWL_WL_HIGH,
        DKIM_SIGNED,DKIM_VALID,DKIM_VALID_AU,DKIM_VALID_EF,RCVD_IN_DNSWL_HI,
        SPF_HELO_NONE,SPF_PASS autolearn=ham autolearn_force=no version=3.4.6
X-Spam-Checker-Version: SpamAssassin 3.4.6 (2021-04-09) on
        lindbergh.monkeyblade.net
Precedence: bulk
List-ID: <linux-xfs.vger.kernel.org>
X-Mailing-List: linux-xfs@vger.kernel.org

From: Darrick J. Wong <djwong@kernel.org>

If someone sets kernel.core_uses_pid (or kernel.core_pattern), any
coredumps generated by fstests might have names that are longer than
just "core".  Since the pid isn't all that useful by itself, let's
record the coredumps by hash when we save them, so that we don't waste
space storing identical crash dumps.

Signed-off-by: Darrick J. Wong <djwong@kernel.org>
---
 check     |   26 ++++++++++++++++++++++----
 common/rc |   16 ++++++++++++++++
 2 files changed, 38 insertions(+), 4 deletions(-)


diff --git a/check b/check
index af23572ccc..654d986b27 100755
--- a/check
+++ b/check
@@ -913,11 +913,19 @@ function run_section()
 			sts=$?
 		fi
 
-		if [ -f core ]; then
-			_dump_err_cont "[dumped core]"
-			mv core $RESULT_BASE/$seqnum.core
+		# If someone sets kernel.core_pattern or kernel.core_uses_pid,
+		# coredumps generated by fstests might have a longer name than
+		# just "core".  Use globbing to find the most common patterns,
+		# assuming there are no other coredump capture packages set up.
+		local cores=0
+		for i in core core.*; do
+			test -f "$i" || continue
+			if ((cores++ == 0)); then
+				_dump_err_cont "[dumped core]"
+			fi
+			_save_coredump "$i"
 			tc_status="fail"
-		fi
+		done
 
 		if [ -f $seqres.notrun ]; then
 			$timestamp && _timestamp
@@ -950,6 +958,16 @@ function run_section()
 			# of the check script itself.
 			(_adjust_oom_score 250; _check_filesystems) || tc_status="fail"
 			_check_dmesg || tc_status="fail"
+
+			# Save any coredumps from the post-test fs checks
+			for i in core core.*; do
+				test -f "$i" || continue
+				if ((cores++ == 0)); then
+					_dump_err_cont "[dumped core]"
+				fi
+				_save_coredump "$i"
+				tc_status="fail"
+			done
 		fi
 
 		# Reload the module after each test to check for leaks or
diff --git a/common/rc b/common/rc
index d1f3d56bf8..9750d06a9a 100644
--- a/common/rc
+++ b/common/rc
@@ -4948,6 +4948,22 @@ _create_file_sized()
 	return $ret
 }
 
+_save_coredump()
+{
+	local path="$1"
+
+	local core_hash="$(_md5_checksum "$path")"
+	local out_file="$RESULT_BASE/$seqnum.core.$core_hash"
+
+	if [ -s "$out_file" ]; then
+		rm -f "$path"
+		return
+	fi
+	rm -f "$out_file"
+
+	mv "$path" "$out_file"
+}
+
 init_rc
 
 ################################################################################

